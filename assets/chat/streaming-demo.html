<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Streaming vs Non-Streaming — Tony’s Agent</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;background:#0b1020;color:#e6e9f2}
  header{padding:20px 16px;border-bottom:1px solid #1b2344}
  main{max-width:960px;margin:0 auto;padding:20px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:16px}
  .card{background:#0f1733;border:1px solid #1b2344;border-radius:12px;overflow:hidden}
  .card h3{margin:0;padding:12px 14px;border-bottom:1px solid #1b2344;font-size:14px;color:#9fb3ff}
  .card .content{padding:14px;min-height:160px;white-space:pre-wrap}
  textarea{width:100%;min-height:80px;border-radius:10px;border:1px solid #1b2344;background:#0f1733;color:#e6e9f2;padding:10px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{background:#4f46e5;color:#fff;border:0;border-radius:10px;padding:10px 14px;cursor:pointer}
  button.secondary{background:#223; color:#cbd5ff}
  .tiny{font-size:12px;color:#9aa4bf}
  .badge{font-size:12px;color:#cbd5ff;background:#172047;border:1px solid #2a3673;border-radius:999px;padding:4px 8px}
</style>
</head>
<body>
  <header>
    <div style="max-width:960px;margin:0 auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
        <div>
          <div class="badge">Tony’s Agent Demo</div>
          <h1 style="margin:8px 0 0;font-size:20px;">Streaming vs Non-Streaming</h1>
          <p class="tiny">Same tokens, different UX. Left = non-stream; Right = streaming.</p>
        </div>
        <div class="tiny">Endpoint: <span id="ep"></span></div>
      </div>
    </div>
  </header>

  <main>
    <label for="q" class="tiny">Your question</label>
    <textarea id="q">How did you pivot into AI, and which dashboards best show your HR analytics work?</textarea>
    <div class="controls">
      <button id="run">Run side-by-side</button>
      <button id="cancel" class="secondary">Cancel streaming</button>
      <span class="tiny" id="timers"></span>
    </div>

    <div class="row">
      <div class="card">
        <h3>Non-Streaming (full response)</h3>
        <div class="content" id="nonstream">—</div>
      </div>
      <div class="card">
        <h3>Streaming (tokens arrive live)</h3>
        <div class="content" id="stream">—</div>
      </div>
    </div>
  </main>

<script>
const ENDPOINT = "https://<your-worker-subdomain>.workers.dev"; // <-- set me
document.getElementById("ep").textContent = ENDPOINT;

let readerAbort;

document.getElementById("run").onclick = async () => {
  const question = document.getElementById("q").value.trim();
  const non = document.getElementById("nonstream");
  const stream = document.getElementById("stream");
  non.textContent = "…";
  stream.textContent = "";

  // payload mirrors your widget: send the last user message
  const payload = { messages: [{ role: "user", content: question }] };

  // kick both modes at once
  const t0 = performance.now();
  const nonP = fetch(ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  }).then(r => r.json()).then(j => {
    non.textContent = j.content || j?.content || j?.role === "assistant" ? j.content : JSON.stringify(j, null, 2);
  }).catch(e => non.textContent = "Error: " + e.message);

  const t1 = performance.now();
  const streamP = streamChat(ENDPOINT + "?stream=1", payload, token => {
    stream.textContent += token;
  });

  const [_, __] = await Promise.allSettled([nonP, streamP]);
  const dtNon = (performance.now() - t0).toFixed(0);
  const dtStart = (t1 - t0).toFixed(0);
  document.getElementById("timers").textContent = `Started in ~${dtStart}ms. Non-stream finished in ~${dtNon}ms.`;
};

document.getElementById("cancel").onclick = () => {
  if (readerAbort) { readerAbort.abort(); readerAbort = null; }
};

async function streamChat(endpoint, payload, onToken) {
  readerAbort = new AbortController();
  const res = await fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
    signal: readerAbort.signal
  });
  if (!res.ok || !res.body) { onToken("\n[stream error]"); return; }

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });

    const chunks = buffer.split("\n\n"); // SSE frames
    buffer = chunks.pop() || "";
    for (const raw of chunks) {
      const line = raw.trim();
      if (!line.startsWith("data:")) continue;
      const data = line.slice(5).trim();
      if (data === "[DONE]") { readerAbort = null; return; }
      try {
        const json = JSON.parse(data);
        const delta = json.choices?.[0]?.delta?.content || "";
        if (delta) onToken(delta);
      } catch (e) { /* ignore partials */ }
    }
  }
  readerAbort = null;
}
</script>
</body>
</html>
